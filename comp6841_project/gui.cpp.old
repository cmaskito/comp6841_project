#include <Windows.h>

#include "gui.h"
#include "imgui/imgui.h"
#include "imgui/imgui_impl_dx11.h"
#include "imgui/imgui_impl_win32.h"
#include <dwmapi.h>
#include <d3d11.h>
#include <iostream>
#include "globals.h"


// Forward declare message handler from imgui_impl_win32.cpp
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI gui::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
        return true;

    switch (msg)
    {
    case WM_SIZE:
        if (wParam == SIZE_MINIMIZED)
            return 0;
        g_ResizeWidth = (UINT)LOWORD(lParam); // Queue resize
        g_ResizeHeight = (UINT)HIWORD(lParam);
        return 0;
    case WM_SYSCOMMAND:
        if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
            return 0;
        break;
    case WM_DESTROY:
        ::PostQuitMessage(0);
        return 0;
    }
    return ::DefWindowProcW(hWnd, msg, wParam, lParam);
}
//LRESULT CALLBACK gui::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
//{
//    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
//        return true;
//
//    switch (msg)
//    {
//    case WM_SIZE:
//        if (wParam == SIZE_MINIMIZED)
//            return 0;
//        g_ResizeWidth = (UINT)LOWORD(lParam); // Queue resize
//        g_ResizeHeight = (UINT)HIWORD(lParam);
//        return 0;
//    case WM_SYSCOMMAND:
//        if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
//            return 0;
//        break;
//    case WM_DESTROY:
//        ::PostQuitMessage(0);
//        return 0;
//    case WM_LBUTTONDOWN:
//        gui::position = MAKEPOINTS(lParam);
//        return 0;
//    case WM_MOUSEMOVE:
//        if (wParam == MK_LBUTTON) {
//            const auto points = MAKEPOINTS(lParam);
//            auto rect = RECT();
//            GetWindowRect(gui::hWnd, &rect);
//            
//            rect.left += points.x - gui::position.x;
//            rect.top += points.y - gui::position.y;
//
//            if (gui::position.x >= 0 &&
//                gui::position.x <= gui::WIDTH &&
//                gui::position.y >= 0 &&
//                gui::position.y <= 19
//                ) {
//                SetWindowPos(
//                    gui::hWnd,
//                    HWND_TOPMOST,
//                    rect.left,
//                    rect.top,
//                    0,
//                    0,
//                    SWP_SHOWWINDOW | SWP_NOSIZE | SWP_NOZORDER);
//            }
//        }
//    }
//    return DefWindowProcW(hWnd, msg, wParam, lParam);
//}

int gui::doGui() {
    // Make process DPI aware and obtain main monitor scale
    ImGui_ImplWin32_EnableDpiAwareness();
    float main_scale = ImGui_ImplWin32_GetDpiScaleForMonitor(::MonitorFromPoint(POINT{ 0, 0 }, MONITOR_DEFAULTTOPRIMARY));

    // Create application window
    WNDCLASSEXW wc = { sizeof(wc), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(nullptr), nullptr, nullptr, nullptr, nullptr, L"ImGui Example", nullptr };
    ::RegisterClassExW(&wc);
    HWND hwnd = ::CreateWindowEx(WS_EX_LAYERED | WS_EX_TOPMOST | WS_EX_NOACTIVATE, _T("Dear ImGui DirectX11 Example"), NULL, WS_POPUP, 100, 100, (int)(1280 * main_scale), (int)(800 * main_scale), nullptr, nullptr, wc.hInstance, nullptr);
    SetLayeredWindowAttributes(hwnd, RGB(0, 0, 0), 0, ULW_COLORKEY);

    // Initialize Direct3D
    if (!CreateDeviceD3D(hwnd))
    {
        CleanupDeviceD3D();
        ::UnregisterClassW(wc.lpszClassName, wc.hInstance);
        return 1;
    }

    // Show the window
    ::ShowWindow(hwnd, SW_SHOWDEFAULT);
    ::UpdateWindow(hwnd);

    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls

    // Setup Dear ImGui style
    ImGui::StyleColorsDark();
    //ImGui::StyleColorsLight();

    // Setup scaling
    ImGuiStyle& style = ImGui::GetStyle();
    style.ScaleAllSizes(main_scale);        // Bake a fixed style scale. (until we have a solution for dynamic style scaling, changing this requires resetting Style + calling this again)
    style.FontScaleDpi = main_scale;        // Set initial font scale. (using io.ConfigDpiScaleFonts=true makes this unnecessary. We leave both here for documentation purpose)

    // Setup Platform/Renderer backends
    ImGui_ImplWin32_Init(hwnd);
    ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

    // Load Fonts
    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.
    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.
    // - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).
    // - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.
    // - Read 'docs/FONTS.md' for more instructions and details.
    // - Remember that in C/C++ if you want to include a backslash \ in a string literal you need to write a double backslash \\ !
    //style.FontSizeBase = 20.0f;
    //io.Fonts->AddFontDefault();
    //io.Fonts->AddFontFromFileTTF("c:\\Windows\\Fonts\\segoeui.ttf");
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/DroidSans.ttf");
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/Roboto-Medium.ttf");
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/Cousine-Regular.ttf");
    //ImFont* font = io.Fonts->AddFontFromFileTTF("c:\\Windows\\Fonts\\ArialUni.ttf");
    //IM_ASSERT(font != nullptr);

    // Our state
    bool show_demo_window = true;
    bool show_another_window = false;
    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

    // Main loop
    bool done = false;
    while (!done)
    {
        // Poll and handle messages (inputs, window resize, etc.)
        // See the WndProc() function below for our to dispatch events to the Win32 backend.
        MSG msg;
        while (::PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE))
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
            if (msg.message == WM_QUIT)
                done = true;
        }
        if (done)
            break;

        // Handle window being minimized or screen locked
        if (g_SwapChainOccluded && g_pSwapChain->Present(0, DXGI_PRESENT_TEST) == DXGI_STATUS_OCCLUDED)
        {
            ::Sleep(10);
            continue;
        }
        g_SwapChainOccluded = false;

        // Handle window resize (we don't resize directly in the WM_SIZE handler)
        if (g_ResizeWidth != 0 && g_ResizeHeight != 0)
        {
            CleanupRenderTarget();
            g_pSwapChain->ResizeBuffers(0, g_ResizeWidth, g_ResizeHeight, DXGI_FORMAT_UNKNOWN, 0);
            g_ResizeWidth = g_ResizeHeight = 0;
            CreateRenderTarget();
        }

        // Start the Dear ImGui frame
        ImGui_ImplDX11_NewFrame();
        ImGui_ImplWin32_NewFrame();
        ImGui::NewFrame();

        // 1. Show the big demo window (Most of the sample code is in ImGui::ShowDemoWindow()! You can browse its code to learn more about Dear ImGui!).
        if (show_demo_window)
            ImGui::ShowDemoWindow(&show_demo_window);

        // 2. Show a simple window that we create ourselves. We use a Begin/End pair to create a named window.
        {
            static float f = 0.0f;
            static int counter = 0;

            ImGui::Begin("Hello, world!");                          // Create a window called "Hello, world!" and append into it.

            ImGui::Text("This is some useful text.");               // Display some text (you can use a format strings too)
            ImGui::Checkbox("Demo Window", &show_demo_window);      // Edit bools storing our window open/close state
            ImGui::Checkbox("Another Window", &show_another_window);

            ImGui::SliderFloat("float", &f, 0.0f, 1.0f);            // Edit 1 float using a slider from 0.0f to 1.0f
            ImGui::ColorEdit3("clear color", (float*)&clear_color); // Edit 3 floats representing a color

            if (ImGui::Button("Button"))                            // Buttons return true when clicked (most widgets return true when edited/activated)
                counter++;
            ImGui::SameLine();
            ImGui::Text("counter = %d", counter);

            ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
            ImGui::End();
        }

        // 3. Show another simple window.
        if (show_another_window)
        {
            ImGui::Begin("Another Window", &show_another_window);   // Pass a pointer to our bool variable (the window will have a closing button that will clear the bool when clicked)
            ImGui::Text("Hello from another window!");
            if (ImGui::Button("Close Me"))
                show_another_window = false;
            ImGui::End();
        }

        // Rendering
        ImGui::Render();
        const float clear_color_with_alpha[4] = { 0.f, 0.f, 0.f, 0.f };
        g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, nullptr);
        g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, clear_color_with_alpha);
        ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

        // Present
        HRESULT hr = g_pSwapChain->Present(1, 0);   // Present with vsync
        //HRESULT hr = g_pSwapChain->Present(0, 0); // Present without vsync
        g_SwapChainOccluded = (hr == DXGI_STATUS_OCCLUDED);
    }

    // Cleanup
    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    CleanupDeviceD3D();
    ::DestroyWindow(hwnd);
    ::UnregisterClassW(wc.lpszClassName, wc.hInstance);

    return 0;
}

void gui::CreateHWindow() {
    wc = {
        sizeof(wc),
        CS_CLASSDC,
        WndProc,
        0L,
        0L,
        GetModuleHandle(nullptr),
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        L"TESNAME",
        nullptr
    };

    RegisterClassExW(&wc);

    hWnd = CreateWindowExW(
        WS_EX_TOPMOST | WS_EX_LAYERED,
        wc.lpszClassName,
        L"TEST",
        WS_POPUP,
        100,
        100,
        1920,
        1080,
        nullptr,
        nullptr,
        wc.hInstance,
        nullptr
    );

    SetLayeredWindowAttributes(hWnd, RGB(0, 0, 0), 0, ULW_COLORKEY);

    ShowWindow(hWnd, SW_SHOWDEFAULT);
    UpdateWindow(hWnd);

}

void gui::DestroyHWindow() {
    DestroyWindow(hWnd);
    UnregisterClassW(wc.lpszClassName, wc.hInstance);
}

bool gui::CreateDeviceD3D(HWND hWnd)
{
    // Setup swap chain
    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory(&sd, sizeof(sd));
    sd.BufferCount = 2;
    sd.BufferDesc.Width = 0;
    sd.BufferDesc.Height = 0;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = hWnd;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.Windowed = TRUE;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

    UINT createDeviceFlags = 0;
    //createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
    D3D_FEATURE_LEVEL featureLevel;
    const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
    HRESULT res = D3D11CreateDeviceAndSwapChain(
        nullptr,
        D3D_DRIVER_TYPE_HARDWARE,
        nullptr,
        createDeviceFlags,
        featureLevelArray,
        2,
        D3D11_SDK_VERSION,
        &sd,
        &g_pSwapChain,
        &g_pd3dDevice,
        &featureLevel,
        &g_pd3dDeviceContext
    );
    if (res == DXGI_ERROR_UNSUPPORTED) // Try high-performance WARP software driver if hardware is not available.
        res = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_WARP, nullptr, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext);
    if (res != S_OK)
        return false;

    CreateRenderTarget();
    return true;
}

void gui::CleanupDeviceD3D()
{
    CleanupRenderTarget();
    if (g_pSwapChain) { g_pSwapChain->Release(); g_pSwapChain = nullptr; }
    if (g_pd3dDeviceContext) { g_pd3dDeviceContext->Release(); g_pd3dDeviceContext = nullptr; }
    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = nullptr; }
}

void gui::CreateRenderTarget()
{
    ID3D11Texture2D* pBackBuffer;
    g_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
    g_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, &g_mainRenderTargetView);
    pBackBuffer->Release();
}

void gui::CleanupRenderTarget()
{
    if (g_mainRenderTargetView) { g_mainRenderTargetView->Release(); g_mainRenderTargetView = nullptr; }
}

void gui::CreateImGui() {
    IMGUI_CHECKVERSION();
    imguiContextDX11 = ImGui::CreateContext();
    //ImGui::SetCurrentContext(imguiContextDX11);
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;

    // Setup Dear ImGui style
    ImGui::StyleColorsDark();

    // Setup scaling
    ImGuiStyle& style = ImGui::GetStyle();
    // Setup Platform/Renderer backends
    ImGui_ImplWin32_Init(hWnd);
    ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);
}

void gui::DestroyImGui() {
    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();
}

void gui::Render() {
    //ImGui::SetCurrentContext(imguiContextDX11);
    ImGui_ImplDX11_NewFrame();
    ImGui_ImplWin32_NewFrame();

    ImGui::NewFrame();
 
    //ImGui::SetNextWindowPos({ 0, 0 });/*
    //ImGui::SetNextWindowSize({ WIDTH, HEIGHT });*/
    ImGui::Begin(
        "COMP6841 PROJECT - CSGO CHEATS", 
        &isOpen
        /*ImGuiWindowFlags_NoResize 
        | ImGuiWindowFlags_NoCollapse*/
    );     // Create a window called "Hello, world!" and append into it.
 
    ImGui::Checkbox("Aimbot", &globals::aimbotActive);
    ImGui::Checkbox("BHop", &globals::bHopActive);
 
 
    ImGui::End();

    ImGui::Render();
    const float clear_color_with_alpha[4] = { 0.f, 0.f, 0.f, 0.f };
    g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, nullptr);
    g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, clear_color_with_alpha);
    ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

    // Present
    HRESULT hr = g_pSwapChain->Present(1, 0);   // Present with vsync
    //HRESULT hr = g_pSwapChain->Present(0, 0); // Present without vsync
    g_SwapChainOccluded = (hr == DXGI_STATUS_OCCLUDED);
}

//#include "gui.h"
//#include "imgui/imgui.h"
//#include "imgui/imgui_impl_dx9.h"
//#include "imgui/imgui_impl_win32.h"
//#include "globals.h"
//#include <iostream>
//
// //Helper functions
//bool gui::CreateDeviceD3D()
//{
//    if ((g_pD3D = Direct3DCreate9(D3D_SDK_VERSION)) == nullptr)
//        return false;
//
//    // Create the D3DDevice
//    ZeroMemory(&g_d3dpp, sizeof(g_d3dpp));
//    g_d3dpp.Windowed = TRUE;
//    g_d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
//    g_d3dpp.BackBufferFormat = D3DFMT_UNKNOWN; // Need to use an explicit format with alpha if needing per-pixel alpha composition.
//    g_d3dpp.EnableAutoDepthStencil = TRUE;
//    g_d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
//    g_d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_ONE;           // Present with vsync
//    //g_d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;   // Present without vsync, maximum unthrottled framerate
//    if (g_pD3D->CreateDevice(
//        D3DADAPTER_DEFAULT, 
//        D3DDEVTYPE_HAL, 
//        hWnd, 
//        D3DCREATE_HARDWARE_VERTEXPROCESSING, 
//        &g_d3dpp, 
//        &g_pd3dDevice) < 0)
//        return false;
//
//    return true;
//}
//
//void gui::CleanupDeviceD3D()
//{
//    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = nullptr; }
//    if (g_pD3D) { g_pD3D->Release(); g_pD3D = nullptr; }
//}
//
//void gui::ResetDevice()
//{
//    ImGui_ImplDX9_InvalidateDeviceObjects();
//    HRESULT hr = g_pd3dDevice->Reset(&g_d3dpp);
//    if (hr == D3DERR_INVALIDCALL)
//        IM_ASSERT(0);
//    ImGui_ImplDX9_CreateDeviceObjects();
//}
//
//// Forward declare message handler from imgui_impl_win32.cpp
//extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
//
//// Win32 message handler
//// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
//// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.
//// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.
//// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
//LRESULT WINAPI gui::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
//{
//    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
//        return true;
//
//    switch (msg)
//    {
//    case WM_SIZE:
//        if (wParam == SIZE_MINIMIZED)
//            return 0;
//        g_ResizeWidth = (UINT)LOWORD(lParam); // Queue resize
//        g_ResizeHeight = (UINT)HIWORD(lParam);
//        return 0;
//    case WM_SYSCOMMAND:
//        if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
//            return 0;
//        break;
//    case WM_DESTROY:
//        ::PostQuitMessage(0);
//        return 0;
//    case WM_LBUTTONDOWN:
//        gui::position = MAKEPOINTS(lParam);
//        return 0;
//    case WM_MOUSEMOVE:
//        if (wParam == MK_LBUTTON) {
//            const auto points = MAKEPOINTS(lParam);
//            auto rect = RECT();
//            GetWindowRect(gui::hWnd, &rect);
//            
//            rect.left += points.x - gui::position.x;
//            rect.top += points.y - gui::position.y;
//
//            if (gui::position.x >= 0 &&
//                gui::position.x <= gui::WIDTH &&
//                gui::position.y >= 0 &&
//                gui::position.y <= 19
//                ) {
//                SetWindowPos(
//                    gui::hWnd,
//                    HWND_TOPMOST,
//                    rect.left,
//                    rect.top,
//                    0,
//                    0,
//                    SWP_SHOWWINDOW | SWP_NOSIZE | SWP_NOZORDER);
//            }
//        }
//    }
//    return ::DefWindowProcW(hWnd, msg, wParam, lParam);
//}
//
//void gui::CreateHWindow(const char* windowName, const char* className) {
//    wc = {
//        sizeof(wc),
//        CS_CLASSDC,
//        WndProc,
//        0L,
//        0L,
//        GetModuleHandle(nullptr),
//        nullptr,
//        nullptr,
//        nullptr,
//        nullptr,
//        className,
//        nullptr
//    };
//
//    RegisterClassExA(&wc);
//    hWnd = CreateWindowExA(
//        WS_EX_TOPMOST,
//        wc.lpszClassName,
//        windowName,
//        WS_POPUP,
//        100,
//        100,
//        WIDTH,
//        HEIGHT,
//        nullptr,
//        nullptr,
//        wc.hInstance,
//        nullptr
//    );
//    std::cout << "hWnd in gui " << hWnd << std::endl;
//
//
//    ShowWindow(hWnd, SW_SHOWDEFAULT);
//    UpdateWindow(hWnd);
//}
//
//void gui::DestroyHWindow() {
//    DestroyWindow(hWnd);
//    UnregisterClassA(wc.lpszClassName, wc.hInstance);
//}
//
//void gui::CreateImGui() {
//    IMGUI_CHECKVERSION();
//    imguiContextDX9 = ImGui::CreateContext();
//    ImGui::SetCurrentContext(imguiContextDX9);
//    ImGuiIO& io = ImGui::GetIO(); (void)io;
//    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
//    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls
//
//    // Setup Dear ImGui style
//    ImGui::StyleColorsDark();
//
//    // Setup scaling
//    ImGuiStyle& style = ImGui::GetStyle();
//    // Setup Platform/Renderer backends
//    ImGui_ImplWin32_Init(hWnd);
//    ImGui_ImplDX9_Init(g_pd3dDevice);
//}
//
//void gui::DestroyImGui() {
//    ImGui_ImplDX9_Shutdown();
//    ImGui_ImplWin32_Shutdown();
//    ImGui::DestroyContext();
//}
//
//void gui::Render() {
//    MSG msg;
//    while (::PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE))
//    {
//        ::TranslateMessage(&msg);
//        ::DispatchMessage(&msg);
//    }
//
//    // Start the ImGui frame
//    ImGui::SetCurrentContext(imguiContextDX9);
//    std::cout << "gui " << ImGui::GetCurrentContext() << std::endl;
//
//    ImGui_ImplDX9_NewFrame();
//    ImGui_ImplWin32_NewFrame();
//    ImGui::NewFrame();
//
//    ImGui::SetNextWindowPos({ 0, 0 });
//    ImGui::SetNextWindowSize({ WIDTH, HEIGHT });
//    ImGui::Begin(
//        "COMP6841 PROJECT - CSGO CHEATS", 
//        &isOpen, 
//        ImGuiWindowFlags_NoResize 
//        | ImGuiWindowFlags_NoCollapse
//    );     // Create a window called "Hello, world!" and append into it.
//
//    ImGui::Checkbox("Aimbot", &globals::aimbotActive);
//    ImGui::Checkbox("BHop", &globals::bHopActive);
//
//
//    ImGui::End();
//}
//
//void gui::RenderHelper() {
//    ImGui::EndFrame();
//    g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
//    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
//    g_pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
//    g_pd3dDevice->Clear(0, nullptr, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, D3DCOLOR_RGBA(0, 0, 0, 255), 1.0f, 0);
//    if (g_pd3dDevice->BeginScene() >= 0)
//    {
//        ImGui::Render();
//        ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
//        g_pd3dDevice->EndScene();
//    }
//    HRESULT result = g_pd3dDevice->Present(nullptr, nullptr, nullptr, nullptr);
//    if (result == D3DERR_DEVICELOST)
//        g_DeviceLost = true;
//}